# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

import metabedUnlexer


class metabedUnparser(Grammarinator):

    def __init__(self, unlexer):
        super(metabedUnparser, self).__init__()
        self.unlexer = unlexer

    @depthcontrol
    def bed(self):
        current = self.create_node(UnparserRule(name='bed'))
        current += self.unlexer.HEADER()
        current += self.create_node(UnlexerRule(src='\n\n'))
        current += self.unlexer.LINE()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.chrom()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.coordinate()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.name()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.score()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.strand()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.thickStart()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.thickEnd()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.itemRgb()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.blockCount()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.blockSizes()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.blockStarts()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.chromName()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.unlexer.CHAR()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.unlexer.NUMBER()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.unlexer.NUM255()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.unlexer.NUM()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.unlexer.NUM3()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.unlexer.SEPARATOR()
        current += self.create_node(UnlexerRule(src='\n'))
        return current
    bed.min_depth = 1

    @depthcontrol
    def chrom(self):
        current = self.create_node(UnparserRule(name='chrom'))
        current += self.create_node(UnlexerRule(src='chrom\n'))
        current += self.create_node(UnlexerRule(src='\t: '))
        choice = self.choice([0 if [0, 0, 0][i] > self.unlexer.max_depth else w *
                              self.unlexer.weights.get(('alt_52', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_52', choice)] = self.unlexer.weights.get(
            ('alt_52', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='CHAR+'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='chromName'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='CHAR+ | chromName'))
        current += self.create_node(UnlexerRule(src=';'))
        return current
    chrom.min_depth = 0

    @depthcontrol
    def coordinate(self):
        current = self.create_node(UnparserRule(name='coordinate'))
        current += self.create_node(UnlexerRule(src='coordinate\n'))
        current += self.create_node(UnlexerRule(
            src='\t: NUMBER SEPARATOR NUMBER;'))
        return current
    coordinate.min_depth = 0

    @depthcontrol
    def name(self):
        current = self.create_node(UnparserRule(name='name'))
        current += self.create_node(UnlexerRule(src='name\n'))
        current += self.create_node(UnlexerRule(src='\t: CHAR+;'))
        return current
    name.min_depth = 0

    @depthcontrol
    def score(self):
        current = self.create_node(UnparserRule(name='score'))
        current += self.create_node(UnlexerRule(src='score\n'))
        current += self.create_node(UnlexerRule(src='\t: '))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w *
                              self.unlexer.weights.get(('alt_66', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_66', choice)] = self.unlexer.weights.get(
            ('alt_66', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(
                src='NUM | NUM NUM | NUM NUM NUM | \'1000\''))
        elif choice == 1:
            current += self.create_node(UnlexerRule(
                src='NUM | NUM NUM | NUM NUM NUM | \'1000\' | NUM \'.\' NUM+'))
        current += self.create_node(UnlexerRule(src=';'))
        return current
    score.min_depth = 0

    @depthcontrol
    def strand(self):
        current = self.create_node(UnparserRule(name='strand'))
        current += self.create_node(UnlexerRule(src='strand\n'))
        current += self.create_node(UnlexerRule(src='\t: '))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w *
                              self.unlexer.weights.get(('alt_74', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_74', choice)] = self.unlexer.weights.get(
            ('alt_74', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(
                UnlexerRule(src='\'+\' | \'-\' | \'.\''))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='\'+\' | \'-\''))
        current += self.create_node(UnlexerRule(src=';'))
        return current
    strand.min_depth = 0

    @depthcontrol
    def thickStart(self):
        current = self.create_node(UnparserRule(name='thickStart'))
        current += self.create_node(UnlexerRule(src='thickStart\n'))
        current += self.create_node(UnlexerRule(src='\t: NUMBER;'))
        return current
    thickStart.min_depth = 0

    @depthcontrol
    def thickEnd(self):
        current = self.create_node(UnparserRule(name='thickEnd'))
        current += self.create_node(UnlexerRule(src='thickEnd\n'))
        current += self.create_node(UnlexerRule(src='\t: NUMBER;'))
        return current
    thickEnd.min_depth = 0

    @depthcontrol
    def itemRgb(self):
        current = self.create_node(UnparserRule(name='itemRgb'))
        current += self.create_node(UnlexerRule(src='itemRgb\n'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w *
                              self.unlexer.weights.get(('alt_85', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_85', choice)] = self.unlexer.weights.get(
            ('alt_85', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='\t: \'0\'\n'))
            current += self.create_node(UnlexerRule(
                src='\t| NUM255 \',\' NUM255 \',\' NUM255;'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(
                src='\t: NUM255 \',\' NUM255 \',\' NUM255;'))
        return current
    itemRgb.min_depth = 0

    @depthcontrol
    def blockCount(self):
        current = self.create_node(UnparserRule(name='blockCount'))
        current += self.create_node(UnlexerRule(src='blockCount\n'))
        current += self.create_node(UnlexerRule(src='\t: NUM;'))
        return current
    blockCount.min_depth = 0

    @depthcontrol
    def blockSizes(self):
        current = self.create_node(UnparserRule(name='blockSizes'))
        current += self.create_node(UnlexerRule(src='blockSizes\n'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w *
                              self.unlexer.weights.get(('alt_94', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_94', choice)] = self.unlexer.weights.get(
            ('alt_94', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(
                UnlexerRule(src='\t: (NUMBER \',\')* NUMBER'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='\t: (NUMBER \',\')+'))
        current += self.create_node(UnlexerRule(src=';'))
        return current
    blockSizes.min_depth = 0

    @depthcontrol
    def blockStarts(self):
        current = self.create_node(UnparserRule(name='blockStarts'))
        current += self.create_node(UnlexerRule(src='blockStarts\n'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w *
                              self.unlexer.weights.get(('alt_101', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_101', choice)] = self.unlexer.weights.get(
            ('alt_101', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(
                UnlexerRule(src='\t: (NUMBER \',\')* NUMBER'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='\t: (NUMBER \',\')+'))
        current += self.create_node(UnlexerRule(src=';'))
        return current
    blockStarts.min_depth = 0

    @depthcontrol
    def chromName(self):
        current = self.create_node(UnparserRule(name='chromName'))
        current += self.create_node(UnlexerRule(src='chromName\n'))
        current += self.create_node(UnlexerRule(
            src='\t: \'chr\' (( NUM | \'1\' NUM | \'2\' NUM3) | \'X\' | \'Y\' | \'M\');'))
        return current
    chromName.min_depth = 0

    default_rule = bed
