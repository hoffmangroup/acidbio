# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *


class metabedUnlexer(Grammarinator):

    def __init__(self, *, max_depth=float('inf'), weights=None, cooldown=1.0):
        super(metabedUnlexer, self).__init__()
        self.unlexer = self
        self.max_depth = max_depth
        self.weights = weights or dict()
        self.cooldown = cooldown

    def EOF(self, *args, **kwargs):
        pass

    @depthcontrol
    def HEADER(self):
        current = self.create_node(UnlexerRule(name='HEADER'))
        current += self.create_node(UnlexerRule(src='grammar bed;'))
        return current
    HEADER.min_depth = 0

    @depthcontrol
    def LINE(self):
        current = self.create_node(UnlexerRule(name='LINE'))
        current += self.create_node(UnlexerRule(src='line\n'))
        choice = self.choice([0 if [0, 0, 0, 0, 0, 0, 0][i] > self.unlexer.max_depth else w *
                              self.unlexer.weights.get(('alt_2', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_2', choice)] = self.unlexer.weights.get(
            ('alt_2', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(
                src='\t: (chrom SEPARATOR coordinate)+\n'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(
                src='\t: (chrom SEPARATOR coordinate SEPARATOR name \'\\n\')+\n'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(
                src='\t: (chrom SEPARATOR coordinate SEPARATOR name SEPARATOR score \'\\n\')+\n'))
        elif choice == 3:
            current += self.create_node(UnlexerRule(
                src='\t: (chrom SEPARATOR coordinate SEPARATOR name SEPARATOR score SEPARATOR strand \'\\n\')+\n'))
        elif choice == 4:
            current += self.create_node(UnlexerRule(
                src='\t: (chrom SEPARATOR coordinate SEPARATOR name SEPARATOR score SEPARATOR strand SEPARATOR thickStart \'\\n\')+\n'))
        elif choice == 5:
            current += self.create_node(UnlexerRule(
                src='\t: (chrom SEPARATOR coordinate SEPARATOR name SEPARATOR score SEPARATOR strand SEPARATOR thickStart SEPARATOR thickEnd \'\\n\')+\n'))
        elif choice == 6:
            current += self.create_node(UnlexerRule(
                src='\t: (chrom SEPARATOR coordinate SEPARATOR name SEPARATOR score SEPARATOR strand SEPARATOR thickStart SEPARATOR thickEnd SEPARATOR itemRgb \'\\n\')+\n'))
        current += self.create_node(UnlexerRule(src=';'))
        return current
    LINE.min_depth = 0

    @depthcontrol
    def CHAR(self):
        current = self.create_node(UnlexerRule(name='CHAR'))
        current += self.create_node(UnlexerRule(src='CHAR\n'))
        current += self.create_node(UnlexerRule(
            src='\t:(\'a\' .. \'z\') | (\'A\' .. \'Z\') | \'_\' | NUM;'))
        return current
    CHAR.min_depth = 0

    @depthcontrol
    def NUMBER(self):
        current = self.create_node(UnlexerRule(name='NUMBER'))
        current += self.create_node(UnlexerRule(src='NUMBER\n'))
        current += self.create_node(UnlexerRule(src='\t: NUM+;'))
        return current
    NUMBER.min_depth = 0

    @depthcontrol
    def NUM255(self):
        current = self.create_node(UnlexerRule(name='NUM255'))
        current += self.create_node(UnlexerRule(src='NUM255\n'))
        current += self.create_node(UnlexerRule(
            src='\t: NUM | NUM NUM | (\'2\' NUM \'0\' .. \'4\' | \'25\' \'0\' .. \'5\');'))
        return current
    NUM255.min_depth = 0

    @depthcontrol
    def NUM(self):
        current = self.create_node(UnlexerRule(name='NUM'))
        current += self.create_node(UnlexerRule(src='NUM\n'))
        current += self.create_node(UnlexerRule(src='\t: \'0\' .. \'9\';'))
        return current
    NUM.min_depth = 0

    @depthcontrol
    def NUM3(self):
        current = self.create_node(UnlexerRule(name='NUM3'))
        current += self.create_node(UnlexerRule(src='NUM3\n'))
        current += self.create_node(UnlexerRule(src='\t: \'0\' .. \'3\';'))
        return current
    NUM3.min_depth = 0

    @depthcontrol
    def SEPARATOR(self):
        current = self.create_node(UnlexerRule(name='SEPARATOR'))
        current += self.create_node(UnlexerRule(src='SEPARATOR\n'))
        current += self.create_node(UnlexerRule(src='\t: \'\\t\' | \' \'+; '))
        return current
    SEPARATOR.min_depth = 0
