# Generated by Grammarinator 19.3+46.gbc14ea2

from itertools import chain
from math import inf
from random import randint, random
from grammarinator.runtime import *


class bedGenerator(Generator):
    start: int
    end: int

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.start = None
        self.end = None

    def EOF(self, *args, **kwargs):
        pass


    @depthcontrol
    def line(self, parent=None):
        current = UnparserRule(name='line', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=1, max=inf):
                    self.chrom(parent=current)        
                    UnlexerRule(src='\t', parent=current)        
                    self.coordinate(parent=current)        
                    UnlexerRule(src='\t', parent=current)        
                    self.name(parent=current)        
                    UnlexerRule(src='\n', parent=current)
        elif choice == 1:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 1, min=1, max=inf):
                    self.chrom(parent=current)        
                    UnlexerRule(src='\t', parent=current)        
                    self.coordinate(parent=current)        
                    UnlexerRule(src='\t', parent=current)       
                    self.name(parent=current)       
                    UnlexerRule(src='\t', parent=current)        
                    self.score(parent=current)        
                    UnlexerRule(src='\n', parent=current)
        elif choice == 2:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 2, min=1, max=inf):
                    self.chrom(parent=current)        
                    UnlexerRule(src='\t', parent=current)        
                    self.coordinate(parent=current)        
                    UnlexerRule(src='\t', parent=current)        
                    self.name(parent=current)        
                    UnlexerRule(src='\t', parent=current)        
                    self.score(parent=current)        
                    UnlexerRule(src='\t', parent=current)       
                    self.strand(parent=current)        
                    UnlexerRule(src='\n', parent=current)        
        self.exit_rule(current)
        return current
    line.min_depth = 3

    @depthcontrol
    def chrom(self, parent=None):
        current = UnparserRule(name='chrom', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=1, max=inf):
                    self.CHAR(parent=current)
        elif choice == 1:
            self.chromName(parent=current)        
        self.exit_rule(current)
        return current
    chrom.min_depth = 1

    @depthcontrol
    def coordinate(self, parent=None):
        current = UnparserRule(name='coordinate', parent=parent)
        self.enter_rule(current)
        start = randint(0, 1e7)
        end = randint(0, 1e7)
        chance = random()
        while chance < 0.999 and start > end:
            start = randint(0, 1e7)
            end = randint(0, 1e7)
        self.start = start
        self.end = end
        UnlexerRule(src=str(start), parent=current)
        UnlexerRule(src='\t', parent=current)
        UnlexerRule(src=str(end), parent=current)              
        self.exit_rule(current)
        return current
    coordinate.min_depth = 2

    @depthcontrol
    def name(self, parent=None):
        current = UnparserRule(name='name', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.CHAR(parent=current)        
        self.exit_rule(current)
        return current
    name.min_depth = 1

    @depthcontrol
    def score(self, parent=None):
        current = UnparserRule(name='score', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.NUM(parent=current)
        elif choice == 1:
            self.NUM(parent=current)
            self.NUM(parent=current)
        elif choice == 2:
            self.NUM(parent=current)
            self.NUM(parent=current)
            self.NUM(parent=current)
        elif choice == 3:
            UnlexerRule(src='1000', parent=current)        
        self.exit_rule(current)
        return current
    score.min_depth = 0

    @depthcontrol
    def strand(self, parent=None):
        current = UnparserRule(name='strand', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='+', parent=current)
        elif choice == 1:
            UnlexerRule(src='-', parent=current)
        elif choice == 2:
            UnlexerRule(src='.', parent=current)        
        self.exit_rule(current)
        return current
    strand.min_depth = 0

    @depthcontrol
    def chromName(self, parent=None):
        current = UnparserRule(name='chromName', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='chr', parent=current)        
        choice = self.model.choice(current, 0, [0 if [1, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            choice = self.model.choice(current, 1, [0 if [1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
            if choice == 0:
                self.NUM(parent=current)
            elif choice == 1:
                UnlexerRule(src='1', parent=current)
                self.NUM(parent=current)
            elif choice == 2:
                UnlexerRule(src='2', parent=current)
                self.NUM3(parent=current)
        elif choice == 1:
            UnlexerRule(src='X', parent=current)
        elif choice == 2:
            UnlexerRule(src='Y', parent=current)
        elif choice == 3:
            UnlexerRule(src='M', parent=current)        
        self.exit_rule(current)
        return current
    chromName.min_depth = 0

    @depthcontrol
    def CHAR(self, parent=None):
        current = UnlexerRule(name='CHAR', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src=self.char_from_list(range(97, 123)), parent=current)
        elif choice == 1:
            UnlexerRule(src=self.char_from_list(range(65, 91)), parent=current)
        elif choice == 2:
            UnlexerRule(src='_', parent=current)
        elif choice == 3:
            self.NUM(parent=current)
        self.exit_rule(current)
        return current
    CHAR.min_depth = 0

    @depthcontrol
    def NUMBER(self, parent=None):
        current = UnlexerRule(name='NUMBER', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.NUM(parent=current)        
        self.exit_rule(current)
        return current
    NUMBER.min_depth = 1

    @depthcontrol
    def NUM(self, parent=None):
        current = UnlexerRule(name='NUM', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.char_from_list(range(48, 58)), parent=current)        
        self.exit_rule(current)
        return current
    NUM.min_depth = 0

    @depthcontrol
    def NUM3(self, parent=None):
        current = UnlexerRule(name='NUM3', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.char_from_list(range(48, 52)), parent=current)        
        self.exit_rule(current)
        return current
    NUM3.min_depth = 0

    default_rule = line
