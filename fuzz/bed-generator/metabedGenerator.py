# Generated by Grammarinator 19.3+46.gbc14ea2

from itertools import chain
from math import inf
from grammarinator.runtime import *


class metabedGenerator(Generator):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    def EOF(self, *args, **kwargs):
        pass

    @depthcontrol
    def bed(self, parent=None):
        current = UnparserRule(name='bed', parent=parent)
        self.enter_rule(current)
        self.HEADER(parent=current)        
        UnlexerRule(src='\n\n', parent=current)        
        self.LINE(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.chrom(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.coordinate(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.name(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.score(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.strand(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.thickStart(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.thickEnd(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.itemRgb(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.blockCount(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.blockSizes(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.blockStarts(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.chromName(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.CHAR(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.NUMBER(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.NUM255(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.NUM(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.NUM3(parent=current)        
        UnlexerRule(src='\n', parent=current)       
        self.exit_rule(current)
        return current
    bed.min_depth = 1

    @depthcontrol
    def HEADER(self, parent=None):
        current = UnlexerRule(name='HEADER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='grammar bed;', parent=current)        
        self.exit_rule(current)
        return current
    HEADER.min_depth = 0

    @depthcontrol
    def LINE(self, parent=None):
        current = UnlexerRule(name='LINE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='line\n', parent=current)        
        UnlexerRule(src='\t: (chrom SEPARATOR coordinate)+\n', parent=current)        
        UnlexerRule(src='\t| (chrom SEPARATOR coordinate SEPARATOR name \'\\n\')+\n', parent=current)        
        UnlexerRule(src='\t| (chrom SEPARATOR coordinate SEPARATOR name SEPARATOR score \'\\n\')+\n', parent=current)        
        UnlexerRule(src='\t| (chrom SEPARATOR coordinate SEPARATOR name SEPARATOR score SEPARATOR strand \'\\n\')+\n', parent=current)        
        UnlexerRule(src='\t| (chrom SEPARATOR coordinate SEPARATOR name SEPARATOR score SEPARATOR strand SEPARATOR thickStart \'\\n\')+\n', parent=current)        
        UnlexerRule(src='\t| (chrom SEPARATOR coordinate SEPARATOR name SEPARATOR score SEPARATOR strand SEPARATOR thickStart SEPARATOR thickEnd \'\\n\')+\n', parent=current)        
        UnlexerRule(src='\t| (chrom SEPARATOR coordinate SEPARATOR name SEPARATOR score SEPARATOR strand SEPARATOR thickStart SEPARATOR thickEnd SEPARATOR itemRgb \'\\n\')+\n', parent=current)        
        UnlexerRule(src=';', parent=current)        
        self.exit_rule(current)
        return current
    LINE.min_depth = 0

    @depthcontrol
    def CHAR(self, parent=None):
        current = UnlexerRule(name='CHAR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CHAR\n', parent=current)        
        UnlexerRule(src='\t:(\'a\' .. \'z\') | (\'A\' .. \'Z\') | \'_\' | NUM;', parent=current)        
        self.exit_rule(current)
        return current
    CHAR.min_depth = 0

    @depthcontrol
    def NUMBER(self, parent=None):
        current = UnlexerRule(name='NUMBER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NUMBER\n', parent=current)        
        UnlexerRule(src='\t: NUM+;', parent=current)        
        self.exit_rule(current)
        return current
    NUMBER.min_depth = 0

    @depthcontrol
    def NUM255(self, parent=None):
        current = UnlexerRule(name='NUM255', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NUM255\n', parent=current)        
        UnlexerRule(src='\t: NUM | NUM NUM | (\'2\' NUM \'0\' .. \'4\' | \'25\' \'0\' .. \'5\');', parent=current)        
        self.exit_rule(current)
        return current
    NUM255.min_depth = 0

    @depthcontrol
    def NUM(self, parent=None):
        current = UnlexerRule(name='NUM', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NUM\n', parent=current)        
        UnlexerRule(src='\t: \'0\' .. \'9\';', parent=current)        
        self.exit_rule(current)
        return current
    NUM.min_depth = 0

    @depthcontrol
    def NUM3(self, parent=None):
        current = UnlexerRule(name='NUM3', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NUM3\n', parent=current)        
        UnlexerRule(src='\t: \'0\' .. \'3\';', parent=current)        
        self.exit_rule(current)
        return current
    NUM3.min_depth = 0

    @depthcontrol
    def SEPARATOR(self, parent=None):
        current = UnlexerRule(name='SEPARATOR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='SEPARATOR\n', parent=current)        
        UnlexerRule(src='\t: \'\\t\' | \' \'+; ', parent=current)        
        self.exit_rule(current)
        return current
    SEPARATOR.min_depth = 0

    @depthcontrol
    def chrom(self, parent=None):
        current = UnparserRule(name='chrom', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='chrom\n', parent=current)        
        UnlexerRule(src='\t: ', parent=current)        
        choice = self.model.choice(current, 0, [0 if [0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='CHAR+', parent=current)
        elif choice == 1:
            UnlexerRule(src='chromName', parent=current)
        elif choice == 2:
            UnlexerRule(src='CHAR+ | chromName', parent=current)        
        UnlexerRule(src=';', parent=current)        
        self.exit_rule(current)
        return current
    chrom.min_depth = 0

    @depthcontrol
    def coordinate(self, parent=None):
        current = UnparserRule(name='coordinate', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='coordinate\n', parent=current)        
        UnlexerRule(src='\t: NUMBER SEPARATOR NUMBER;', parent=current)        
        self.exit_rule(current)
        return current
    coordinate.min_depth = 0

    @depthcontrol
    def name(self, parent=None):
        current = UnparserRule(name='name', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='name\n', parent=current)        
        UnlexerRule(src='\t: CHAR+;', parent=current)        
        self.exit_rule(current)
        return current
    name.min_depth = 0

    @depthcontrol
    def score(self, parent=None):
        current = UnparserRule(name='score', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='score\n', parent=current)        
        UnlexerRule(src='\t: ', parent=current)        
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='NUM | NUM NUM | NUM NUM NUM | \'1000\'', parent=current)
        elif choice == 1:
            UnlexerRule(src='NUM | NUM NUM | NUM NUM NUM | \'1000\' | NUM \'.\' NUM+', parent=current)        
        UnlexerRule(src=';', parent=current)        
        self.exit_rule(current)
        return current
    score.min_depth = 0

    @depthcontrol
    def strand(self, parent=None):
        current = UnparserRule(name='strand', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='strand\n', parent=current)        
        UnlexerRule(src='\t: ', parent=current)        
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='\'+\' | \'-\' | \'.\'', parent=current)
        elif choice == 1:
            UnlexerRule(src='\'+\' | \'-\'', parent=current)        
        UnlexerRule(src=';', parent=current)        
        self.exit_rule(current)
        return current
    strand.min_depth = 0

    @depthcontrol
    def thickStart(self, parent=None):
        current = UnparserRule(name='thickStart', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='thickStart\n', parent=current)        
        UnlexerRule(src='\t: NUMBER;', parent=current)        
        self.exit_rule(current)
        return current
    thickStart.min_depth = 0

    @depthcontrol
    def thickEnd(self, parent=None):
        current = UnparserRule(name='thickEnd', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='thickEnd\n', parent=current)        
        UnlexerRule(src='\t: NUMBER;', parent=current)        
        self.exit_rule(current)
        return current
    thickEnd.min_depth = 0

    @depthcontrol
    def itemRgb(self, parent=None):
        current = UnparserRule(name='itemRgb', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='itemRgb\n', parent=current)        
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='\t: \'0\'\n', parent=current)
            UnlexerRule(src='\t| NUM255 \',\' NUM255 \',\' NUM255;', parent=current)
        elif choice == 1:
            UnlexerRule(src='\t| NUM255 \',\' NUM255 \',\' NUM255;', parent=current)        
        self.exit_rule(current)
        return current
    itemRgb.min_depth = 0

    @depthcontrol
    def blockCount(self, parent=None):
        current = UnparserRule(name='blockCount', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='blockCount\n', parent=current)        
        UnlexerRule(src='\t: NUM;', parent=current)        
        self.exit_rule(current)
        return current
    blockCount.min_depth = 0

    @depthcontrol
    def blockSizes(self, parent=None):
        current = UnparserRule(name='blockSizes', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='blockSizes\n', parent=current)        
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='\t: (NUMBER \',\')* NUMBER', parent=current)
        elif choice == 1:
            UnlexerRule(src='\t: (NUMBER \',\')+', parent=current)        
        UnlexerRule(src=';', parent=current)        
        self.exit_rule(current)
        return current
    blockSizes.min_depth = 0

    @depthcontrol
    def blockStarts(self, parent=None):
        current = UnparserRule(name='blockStarts', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='blockStarts\n', parent=current)        
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='\t: (NUMBER \',\')* NUMBER', parent=current)
        elif choice == 1:
            UnlexerRule(src='\t: (NUMBER \',\')+', parent=current)        
        UnlexerRule(src=';', parent=current)        
        self.exit_rule(current)
        return current
    blockStarts.min_depth = 0

    @depthcontrol
    def chromName(self, parent=None):
        current = UnparserRule(name='chromName', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='chromName\n', parent=current)        
        UnlexerRule(src='\t: \'chr\' (( NUM | \'1\' NUM | \'2\' NUM3) | \'X\' | \'Y\' | \'M\');', parent=current)        
        self.exit_rule(current)
        return current
    chromName.min_depth = 0

    default_rule = bed
