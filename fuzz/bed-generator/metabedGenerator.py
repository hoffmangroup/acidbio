# Generated by Grammarinator 19.3+46.gbc14ea2

from itertools import chain
from math import inf
from grammarinator.runtime import *


class metabedGenerator(Generator):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    def EOF(self, *args, **kwargs):
        pass


    @depthcontrol
    def bed(self, parent=None):
        current = UnparserRule(name='bed', parent=parent)
        self.enter_rule(current)
        self.HEADER(parent=current)        
        UnlexerRule(src='\n\n', parent=current)        
        self.LINE(parent=current)     
        UnlexerRule(src='\n', parent=current)        
        self.chrom(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.coordinate(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.name(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.score(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.strand(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.chromName(parent=current)       
        UnlexerRule(src='\n', parent=current)        
        self.CHAR(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.NUMBER(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.NUM(parent=current)        
        UnlexerRule(src='\n', parent=current)        
        self.NUM3(parent=current)       
        UnlexerRule(src='\n', parent=current)        
        self.exit_rule(current)
        return current
    bed.min_depth = 2

    @depthcontrol
    def HEADER(self, parent=None):
        current = UnlexerRule(name='HEADER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='grammar bed;', parent=current)        
        self.exit_rule(current)
        return current
    HEADER.min_depth = 0

    @depthcontrol
    def LINE(self, parent=None):
        current = UnlexerRule(name='LINE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='line\n', parent=current)        
        UnlexerRule(src='\t: (chrom \'\\t\' coordinate)+\n', parent=current)        
        UnlexerRule(src='\t| (chrom \'\\t\' coordinate \'\\t\' name \'\\n\')+\n', parent=current)        
        UnlexerRule(src='\t| (chrom \'\\t\' coordinate \'\\t\' name \'\\t\' score \'\\n\')+\n', parent=current)
        UnlexerRule(src='\t| (chrom \'\\t\' coordinate \'\\t\' name \'\\t\' score \'\\t\' strand \'\\n\')+\n', parent=current)        
        UnlexerRule(src=';', parent=current)        
        self.exit_rule(current)
        return current
    LINE.min_depth = 0

    @depthcontrol
    def CHAR(self, parent=None):
        current = UnlexerRule(name='CHAR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='CHAR\n', parent=current)        
        UnlexerRule(src='\t:(\'a\' .. \'z\') | (\'A\' .. \'Z\') | \'_\' | NUM;', parent=current)        
        self.exit_rule(current)
        return current
    CHAR.min_depth = 0

    @depthcontrol
    def NUMBER(self, parent=None):
        current = UnlexerRule(name='NUMBER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NUMBER\n', parent=current)        
        UnlexerRule(src='\t: NUM+;', parent=current)        
        self.exit_rule(current)
        return current
    NUMBER.min_depth = 0

    @depthcontrol
    def NUM(self, parent=None):
        current = UnlexerRule(name='NUM', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NUM\n', parent=current)        
        UnlexerRule(src='\t: \'0\' .. \'9\';', parent=current)        
        self.exit_rule(current)
        return current
    NUM.min_depth = 0

    @depthcontrol
    def NUM3(self, parent=None):
        current = UnlexerRule(name='NUM3', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='NUM3\n', parent=current)        
        UnlexerRule(src='\t: \'0\' .. \'3\';', parent=current)        
        self.exit_rule(current)
        return current
    NUM3.min_depth = 0

    @depthcontrol
    def chrom(self, parent=None):
        current = UnparserRule(name='chrom', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='chrom\n', parent=current)        
        UnlexerRule(src='\t: ', parent=current)        
        choice = self.model.choice(current, 0, [0 if [0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='CHAR+', parent=current)
        elif choice == 1:
            UnlexerRule(src='chromName', parent=current)
        elif choice == 2:
            UnlexerRule(src='CHAR+ | chromName', parent=current)        
        UnlexerRule(src=';', parent=current)        
        self.exit_rule(current)
        return current
    chrom.min_depth = 0

    @depthcontrol
    def coordinate(self, parent=None):
        current = UnparserRule(name='coordinate', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='coordinate\n', parent=current)        
        UnlexerRule(src='\t: ', parent=current)        
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='NUM \'\\t\' NUM NUM', parent=current)
        elif choice == 1:
            UnlexerRule(src='NUMBER \'\\t\' NUMBER', parent=current)
        UnlexerRule(src=';', parent=current)        
        self.exit_rule(current)
        return current
    coordinate.min_depth = 1

    @depthcontrol
    def name(self, parent=None):
        current = UnparserRule(name='name', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='name\n', parent=current)        
        UnlexerRule(src='\t: CHAR+;', parent=current)        
        self.exit_rule(current)
        return current
    name.min_depth = 0

    @depthcontrol
    def score(self, parent=None):
        current = UnparserRule(name='score', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='score\n', parent=current)        
        UnlexerRule(src='\t: ', parent=current)        
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='NUM | NUM NUM | NUM NUM NUM | \'1000\'', parent=current)
        elif choice == 1:
            UnlexerRule(src='NUM | NUM NUM | NUM NUM NUM | \'1000\' | NUM \'.\' NUM+', parent=current)        
        UnlexerRule(src=';', parent=current)        
        self.exit_rule(current)
        return current
    score.min_depth = 0

    @depthcontrol
    def strand(self, parent=None):
        current = UnparserRule(name='strand', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='strand\n', parent=current)        
        UnlexerRule(src='\t: ', parent=current)        
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='\'+\' | \'-\' | \'.\'', parent=current)
        elif choice == 1:
            UnlexerRule(src='\'+\' | \'-\'', parent=current)        
        UnlexerRule(src=';', parent=current)        
        self.exit_rule(current)
        return current
    strand.min_depth = 0

    @depthcontrol
    def chromName(self, parent=None):
        current = UnparserRule(name='chromName', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='chromName\n', parent=current)        
        UnlexerRule(src='\t: \'chr\' (( NUM | \'1\' NUM | \'2\' NUM3) | \'X\' | \'Y\' | \'M\');', parent=current)        
        self.exit_rule(current)
        return current
    chromName.min_depth = 0

    default_rule = bed
