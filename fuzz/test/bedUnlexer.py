# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *



class bedUnlexer(Grammarinator):

    def __init__(self, *, max_depth=float('inf'), weights=None, cooldown=1.0):
        super(bedUnlexer, self).__init__()
        self.unlexer = self
        self.max_depth = max_depth
        self.weights = weights or dict()
        self.cooldown = cooldown

    def EOF(self, *args, **kwargs):
        pass

    @depthcontrol
    def CHAR(self):
        current = self.create_node(UnlexerRule(name='CHAR'))
        choice = self.choice([0 if [0, 0, 0, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_0', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_0', choice)] = self.unlexer.weights.get(('alt_0', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src=self.char_from_list(range(97, 123))))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src=self.char_from_list(range(65, 91))))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='_'))
        elif choice == 3:
            current += self.unlexer.NUM()
        return current
    CHAR.min_depth = 0

    @depthcontrol
    def NUMBER(self):
        current = self.create_node(UnlexerRule(name='NUMBER'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.unlexer.NUM()

        return current
    NUMBER.min_depth = 1

    @depthcontrol
    def NUM255(self):
        current = self.create_node(UnlexerRule(name='NUM255'))
        choice = self.choice([0 if [1, 1, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_6', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_6', choice)] = self.unlexer.weights.get(('alt_6', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.NUM()
        elif choice == 1:
            current += self.unlexer.NUM()
            current += self.unlexer.NUM()
        elif choice == 2:
            choice = self.choice([0 if [1, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_10', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_10', choice)] = self.unlexer.weights.get(('alt_10', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.create_node(UnlexerRule(src='2'))
                current += self.unlexer.NUM()
                current += self.create_node(UnlexerRule(src=self.char_from_list(range(48, 53))))
            elif choice == 1:
                current += self.create_node(UnlexerRule(src='25'))
                current += self.create_node(UnlexerRule(src=self.char_from_list(range(48, 54))))
        return current
    NUM255.min_depth = 0

    @depthcontrol
    def NUM(self):
        current = self.create_node(UnlexerRule(name='NUM'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(range(48, 58))))
        return current
    NUM.min_depth = 0

    @depthcontrol
    def NUM3(self):
        current = self.create_node(UnlexerRule(name='NUM3'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(range(48, 52))))
        return current
    NUM3.min_depth = 0

    @depthcontrol
    def SEPARATOR(self):
        current = self.create_node(UnlexerRule(name='SEPARATOR'))
        current += self.create_node(UnlexerRule(src='\t'))
        return current
    SEPARATOR.min_depth = 0

