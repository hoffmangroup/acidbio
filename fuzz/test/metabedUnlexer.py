# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *



class metabedUnlexer(Grammarinator):

    def __init__(self, *, max_depth=float('inf'), weights=None, cooldown=1.0):
        super(metabedUnlexer, self).__init__()
        self.unlexer = self
        self.max_depth = max_depth
        self.weights = weights or dict()
        self.cooldown = cooldown

    def EOF(self, *args, **kwargs):
        pass

    @depthcontrol
    def HEADER(self):
        current = self.create_node(UnlexerRule(name='HEADER'))
        current += self.create_node(UnlexerRule(src='grammar bed;'))
        return current
    HEADER.min_depth = 0

    @depthcontrol
    def LINE(self):
        current = self.create_node(UnlexerRule(name='LINE'))
        current += self.create_node(UnlexerRule(src='line\n'))
        choice = self.choice([0 if [0, 0, 0, 0, 0, 0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_2', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_2', choice)] = self.unlexer.weights.get(('alt_2', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='\t: (chrom SEPARATOR coordinate NEWLINE)+\n'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='\t: (chrom SEPARATOR coordinate SEPARATOR name NEWLINE)+\n'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='\t: (chrom SEPARATOR coordinate SEPARATOR name SEPARATOR score NEWLINE)+\n'))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='\t: (chrom SEPARATOR coordinate SEPARATOR name SEPARATOR score SEPARATOR strand NEWLINE)+\n'))
        elif choice == 4:
            current += self.create_node(UnlexerRule(src='\t: (chrom SEPARATOR coordinate SEPARATOR name SEPARATOR score SEPARATOR strand SEPARATOR thickStart NEWLINE)+\n'))
        elif choice == 5:
            current += self.create_node(UnlexerRule(src='\t: (chrom SEPARATOR coordinate SEPARATOR name SEPARATOR score SEPARATOR strand SEPARATOR thickStart SEPARATOR thickEnd NEWLINE)+\n'))
        elif choice == 6:
            current += self.create_node(UnlexerRule(src='\t: (chrom SEPARATOR coordinate SEPARATOR name SEPARATOR score SEPARATOR strand SEPARATOR thickStart SEPARATOR thickEnd SEPARATOR itemRgb NEWLINE)+\n'))
        elif choice == 7:
            current += self.create_node(UnlexerRule(src='\t: (chrom SEPARATOR coordinate SEPARATOR name SEPARATOR score SEPARATOR strand SEPARATOR thickStart SEPARATOR thickEnd SEPARATOR itemRgb SEPARATOR blockCount SEPARATOR blockSizes NEWLINE)+\n'))
        elif choice == 8:
            current += self.create_node(UnlexerRule(src='\t: (chrom SEPARATOR coordinate SEPARATOR name SEPARATOR score SEPARATOR strand SEPARATOR thickStart SEPARATOR thickEnd SEPARATOR itemRgb SEPARATOR blockCount SEPARATOR blockSizes SEPARATOR blockStarts NEWLINE)+\n'))
        current += self.create_node(UnlexerRule(src=';'))
        return current
    LINE.min_depth = 0

    @depthcontrol
    def NEWLINE(self):
        current = self.create_node(UnlexerRule(name='NEWLINE'))
        current += self.create_node(UnlexerRule(src='NEWLINE\n'))
        current += self.create_node(UnlexerRule(src='\t: '))
        choice = self.choice([0 if [0, 0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_24', i), 1) for i, w in enumerate([1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_24', choice)] = self.unlexer.weights.get(('alt_24', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='\'\\n\''))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='\'\\n\''))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='\'\\n\''))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='\'\\n\'+'))
        elif choice == 4:
            current += self.create_node(UnlexerRule(src='\'\\n\' COMMENT*'))
        current += self.create_node(UnlexerRule(src='\t;'))
        return current
    NEWLINE.min_depth = 0

    @depthcontrol
    def COMMENT(self):
        current = self.create_node(UnlexerRule(name='COMMENT'))
        current += self.create_node(UnlexerRule(src='COMMENT\n'))
        current += self.create_node(UnlexerRule(src='\t: CHAR+ \'\\n\';'))
        return current
    COMMENT.min_depth = 0

    @depthcontrol
    def CHAR(self):
        current = self.create_node(UnlexerRule(name='CHAR'))
        current += self.create_node(UnlexerRule(src='CHAR\n'))
        current += self.create_node(UnlexerRule(src='\t:(\'a\' .. \'z\') | (\'A\' .. \'Z\') | \'_\' | NUM;'))
        return current
    CHAR.min_depth = 0

    @depthcontrol
    def NUMBER(self):
        current = self.create_node(UnlexerRule(name='NUMBER'))
        current += self.create_node(UnlexerRule(src='NUMBER\n'))
        current += self.create_node(UnlexerRule(src='\t: NUM+;'))
        return current
    NUMBER.min_depth = 0

    @depthcontrol
    def NUM255(self):
        current = self.create_node(UnlexerRule(name='NUM255'))
        current += self.create_node(UnlexerRule(src='NUM255\n'))
        current += self.create_node(UnlexerRule(src='\t: NUM | NUM NUM | (\'2\' NUM \'0\' .. \'4\' | \'25\' \'0\' .. \'5\');'))
        return current
    NUM255.min_depth = 0

    @depthcontrol
    def NUM(self):
        current = self.create_node(UnlexerRule(name='NUM'))
        current += self.create_node(UnlexerRule(src='NUM\n'))
        current += self.create_node(UnlexerRule(src='\t: \'0\' .. \'9\';'))
        return current
    NUM.min_depth = 0

    @depthcontrol
    def NUM2(self):
        current = self.create_node(UnlexerRule(name='NUM2'))
        current += self.create_node(UnlexerRule(src='NUM2\n'))
        current += self.create_node(UnlexerRule(src='\t: \'0\' .. \'2\';'))
        return current
    NUM2.min_depth = 0

    @depthcontrol
    def SEPARATOR(self):
        current = self.create_node(UnlexerRule(name='SEPARATOR'))
        current += self.create_node(UnlexerRule(src='SEPARATOR\n'))
        choice = self.choice([0 if [0, 0, 0, 0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_49', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_49', choice)] = self.unlexer.weights.get(('alt_49', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='\t: \'\\t\' | \' \' \' \'+; '))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='\' \' \' \'+;'))
        elif choice == 2:
            current += UnlexerRule(src='')
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='\t: \'\\t\';'))
        elif choice == 4:
            current += self.create_node(UnlexerRule(src='\t: \'\\t\';'))
        elif choice == 5:
            current += self.create_node(UnlexerRule(src='\t: \'\\t\';'))
        elif choice == 6:
            current += self.create_node(UnlexerRule(src='\t: \'\\t\';'))
        return current
    SEPARATOR.min_depth = 0

