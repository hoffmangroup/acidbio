# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

import metabedUnlexer


class metabedUnparser(Grammarinator):

    def __init__(self, unlexer):
        super(metabedUnparser, self).__init__()
        self.unlexer = unlexer
    @depthcontrol
    def bed(self):
        current = self.create_node(UnparserRule(name='bed'))
        current += self.unlexer.HEADER()
        current += self.create_node(UnlexerRule(src='\n\n'))
        current += self.unlexer.LINE()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.chrom()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.coordinate()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.name()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.score()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.strand()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.thickStart()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.thickEnd()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.itemRgb()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.blockCount()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.blockSizes()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.blockStarts()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.chromName()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.unlexer.CHAR()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.unlexer.NUMBER()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.unlexer.NUM255()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.unlexer.NUM()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.unlexer.NUM3()
        current += self.create_node(UnlexerRule(src='\n'))
        current += self.unlexer.SEPARATOR()
        current += self.create_node(UnlexerRule(src='\n'))
        return current
    bed.min_depth = 1

    @depthcontrol
    def chrom(self):
        current = self.create_node(UnparserRule(name='chrom'))
        current += self.create_node(UnlexerRule(src='chrom\n'))
        current += self.create_node(UnlexerRule(src='\t: '))
        choice = self.choice([0 if [0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_56', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_56', choice)] = self.unlexer.weights.get(('alt_56', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='CHAR+'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='chromName'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='CHAR+ | chromName'))
        current += self.create_node(UnlexerRule(src=';'))
        return current
    chrom.min_depth = 0

    @depthcontrol
    def coordinate(self):
        current = self.create_node(UnparserRule(name='coordinate'))
        current += self.create_node(UnlexerRule(src='coordinate\n'))
        current += self.create_node(UnlexerRule(src='\t:'))
        current += self.create_node(UnlexerRule(src='{\n'))
        current += self.create_node(UnlexerRule(src='from random import randint, random\n'))
        current += self.create_node(UnlexerRule(src='start, end = randint(0, 1e6), randint(0, 1e6)\n'))
        current += self.create_node(UnlexerRule(src='chance = random()\n'))
        current += self.create_node(UnlexerRule(src='while chance < 0.999 and start > end:\n'))
        current += self.create_node(UnlexerRule(src='    start, end = randint(0, 1e6), randint(0, 1e6)\n'))
        current += self.create_node(UnlexerRule(src='current += self.create_node(UnlexerRule(src=str(start)))\n'))
        current += self.create_node(UnlexerRule(src='}\n'))
        current += self.create_node(UnlexerRule(src='\tSEPARATOR\n'))
        current += self.create_node(UnlexerRule(src='{\n'))
        current += self.create_node(UnlexerRule(src='current += self.create_node(UnlexerRule(src=str(end)))\n'))
        current += self.create_node(UnlexerRule(src='self.start = start\n'))
        current += self.create_node(UnlexerRule(src='self.end = end\n'))
        current += self.create_node(UnlexerRule(src='}\n'))
        current += self.create_node(UnlexerRule(src='\t;'))
        return current
    coordinate.min_depth = 0

    @depthcontrol
    def name(self):
        current = self.create_node(UnparserRule(name='name'))
        current += self.create_node(UnlexerRule(src='name\n'))
        current += self.create_node(UnlexerRule(src='\t: CHAR+;'))
        return current
    name.min_depth = 0

    @depthcontrol
    def score(self):
        current = self.create_node(UnparserRule(name='score'))
        current += self.create_node(UnlexerRule(src='score\n'))
        current += self.create_node(UnlexerRule(src='\t: '))
        choice = self.choice([0 if [0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_85', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_85', choice)] = self.unlexer.weights.get(('alt_85', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='NUM | NUM NUM | NUM NUM NUM | \'1000\''))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='NUM | NUM NUM | NUM NUM NUM | \'1000\' | NUM \'.\' NUM+'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='NUM*'))
        current += self.create_node(UnlexerRule(src=';'))
        return current
    score.min_depth = 0

    @depthcontrol
    def strand(self):
        current = self.create_node(UnparserRule(name='strand'))
        current += self.create_node(UnlexerRule(src='strand\n'))
        current += self.create_node(UnlexerRule(src='\t: '))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_95', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_95', choice)] = self.unlexer.weights.get(('alt_95', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='\'+\' | \'-\' | \'.\''))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='\'+\' | \'-\''))
        current += self.create_node(UnlexerRule(src=';'))
        return current
    strand.min_depth = 0

    @depthcontrol
    def thickStart(self):
        current = self.create_node(UnparserRule(name='thickStart'))
        current += self.create_node(UnlexerRule(src='thickStart:\n'))
        current += self.create_node(UnlexerRule(src='{\n'))
        current += self.create_node(UnlexerRule(src='from random import randint, random\n'))
        current += self.create_node(UnlexerRule(src='chance = random()\n'))
        current += self.create_node(UnlexerRule(src='if chance < 0.999:\n'))
        current += self.create_node(UnlexerRule(src='    start = randint(self.start, self.end)\n'))
        current += self.create_node(UnlexerRule(src='else:\n'))
        current += self.create_node(UnlexerRule(src='    start = randint(0, 1e6)\n'))
        current += self.create_node(UnlexerRule(src='self.tStart = start\n'))
        current += self.create_node(UnlexerRule(src='current += self.create_node(UnlexerRule(src=str(start)))\n'))
        current += self.create_node(UnlexerRule(src='}\n'))
        current += self.create_node(UnlexerRule(src='\t;'))
        return current
    thickStart.min_depth = 0

    @depthcontrol
    def thickEnd(self):
        current = self.create_node(UnparserRule(name='thickEnd'))
        current += self.create_node(UnlexerRule(src='thickEnd:\n'))
        current += self.create_node(UnlexerRule(src='{'))
        current += self.create_node(UnlexerRule(src='from random import randint, random\n'))
        current += self.create_node(UnlexerRule(src='chance = random()\n'))
        current += self.create_node(UnlexerRule(src='if chance < 0.999:\n'))
        current += self.create_node(UnlexerRule(src='    end = randint(self.tStart, self.end)\n'))
        current += self.create_node(UnlexerRule(src='else:\n'))
        current += self.create_node(UnlexerRule(src='    end = randint(0, 1e6)\n'))
        current += self.create_node(UnlexerRule(src='self.tEnd = end\n'))
        current += self.create_node(UnlexerRule(src='current += self.create_node(UnlexerRule(src=str(end)))\n'))
        current += self.create_node(UnlexerRule(src='}\n'))
        current += self.create_node(UnlexerRule(src='\t;'))
        return current
    thickEnd.min_depth = 0

    @depthcontrol
    def itemRgb(self):
        current = self.create_node(UnparserRule(name='itemRgb'))
        current += self.create_node(UnlexerRule(src='itemRgb\n'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_126', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_126', choice)] = self.unlexer.weights.get(('alt_126', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='\t: \'0\'\n'))
            current += self.create_node(UnlexerRule(src='\t| NUM255 \',\' NUM255 \',\' NUM255;'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='\t: NUM255 \',\' NUM255 \',\' NUM255;'))
        return current
    itemRgb.min_depth = 0

    @depthcontrol
    def blockCount(self):
        current = self.create_node(UnparserRule(name='blockCount'))
        current += self.create_node(UnlexerRule(src='blockCount\n'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_133', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_133', choice)] = self.unlexer.weights.get(('alt_133', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='\t: \'1\' .. \'4\'\n'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='\t" NUM\n'))
        current += self.create_node(UnlexerRule(src='{\n'))
        current += self.create_node(UnlexerRule(src='self.bCount = int(current)\n'))
        current += self.create_node(UnlexerRule(src='}\n'))
        current += self.create_node(UnlexerRule(src='\t;'))
        return current
    blockCount.min_depth = 0

    @depthcontrol
    def blockSizes(self):
        current = self.create_node(UnparserRule(name='blockSizes'))
        current += self.create_node(UnlexerRule(src='blockSizes:\n'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_143', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_143', choice)] = self.unlexer.weights.get(('alt_143', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='{\n'))
            current += self.create_node(UnlexerRule(src='if self.unlexer.max_depth >= 2:\n'))
            current += self.create_node(UnlexerRule(src='    for _ in range(self.bCount - 1):\n'))
            current += self.create_node(UnlexerRule(src='        current += self.unlexer.NUMBER()\n'))
            current += self.create_node(UnlexerRule(src='        current += self.create_node(UnlexerRule(src=\',\'))\n'))
            current += self.create_node(UnlexerRule(src='}\n'))
            current += self.create_node(UnlexerRule(src='\tNUMBER\n'))
            current += self.create_node(UnlexerRule(src='{\n'))
            current += self.create_node(UnlexerRule(src='if self.bCount <= 1:\n'))
            current += self.create_node(UnlexerRule(src='    self.lastBlock = int(str(current))\n'))
            current += self.create_node(UnlexerRule(src='else:\n'))
            current += self.create_node(UnlexerRule(src='    self.lastBlock = int(str(current)[str(current).rfind(\',\') + 1:])\n'))
            current += self.create_node(UnlexerRule(src='}\n'))
            current += self.create_node(UnlexerRule(src=';'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='{\n'))
            current += self.create_node(UnlexerRule(src='if self.unlexer.max_depth >= 2:\n'))
            current += self.create_node(UnlexerRule(src='    for _ in range(self.bCount):\n'))
            current += self.create_node(UnlexerRule(src='        current += self.unlexer.NUMBER()\n'))
            current += self.create_node(UnlexerRule(src='        current += self.create_node(UnlexerRule(src=\',\'))\n'))
            current += self.create_node(UnlexerRule(src='}\n'))
            current += self.create_node(UnlexerRule(src='{\n'))
            current += self.create_node(UnlexerRule(src='if self.bCount == 1:\n'))
            current += self.create_node(UnlexerRule(src='    self.lastBlock = int(str(current))\n'))
            current += self.create_node(UnlexerRule(src='elif self.bCount == 0:\n'))
            current += self.create_node(UnlexerRule(src='    self.lastBlock = 0\n'))
            current += self.create_node(UnlexerRule(src='else:\n'))
            current += self.create_node(UnlexerRule(src='    self.lastBlock = int(str(current)[str(current).rfind(\',\') + 1:])\n'))
            current += self.create_node(UnlexerRule(src='}\n'))
            current += self.create_node(UnlexerRule(src=';'))
        return current
    blockSizes.min_depth = 0

    @depthcontrol
    def blockStarts(self):
        current = self.create_node(UnparserRule(name='blockStarts'))
        current += self.create_node(UnlexerRule(src='blockStarts:\n'))
        current += self.create_node(UnlexerRule(src='{\n'))
        current += self.create_node(UnlexerRule(src='if self.unlexer.max_depth >= 2:\n'))
        current += self.create_node(UnlexerRule(src='    for _ in range(self.bCount - 1):\n'))
        current += self.create_node(UnlexerRule(src='        current += self.unlexer.NUMBER()\n'))
        current += self.create_node(UnlexerRule(src='        current += self.create_node(UnlexerRule(src=\',\'))\n'))
        current += self.create_node(UnlexerRule(src='from random import random\n'))
        current += self.create_node(UnlexerRule(src='if random() < 0.999:\n'))
        current += self.create_node(UnlexerRule(src='    current += self.create_node(UnlexerRule(src=str(self.end - self.lastBlock)))\n'))
        current += self.create_node(UnlexerRule(src='else:\n'))
        current += self.create_node(UnlexerRule(src='    current += self.unlexer.NUM()\n'))
        current += self.create_node(UnlexerRule(src='}\n'))
        current += self.create_node(UnlexerRule(src=';'))
        return current
    blockStarts.min_depth = 0

    @depthcontrol
    def chromName(self):
        current = self.create_node(UnparserRule(name='chromName'))
        current += self.create_node(UnlexerRule(src='chromName\n'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_189', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_189', choice)] = self.unlexer.weights.get(('alt_189', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='\t: \'chr\' (( NUM | \'1\' NUM | \'2\' NUM3) | \'X\' | \'Y\' | \'M\');'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='\t: \'chr\' ( NUM | \'1\' NUM | \'2\' NUM3);'))
        return current
    chromName.min_depth = 0

    default_rule = bed

