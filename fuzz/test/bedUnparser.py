# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

import bedUnlexer


class bedUnparser(Grammarinator):

    def __init__(self, unlexer):
        super(bedUnparser, self).__init__()
        self.unlexer = unlexer
    @depthcontrol
    def line(self):
        current = self.create_node(UnparserRule(name='line'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.chrom()
                current += self.unlexer.SEPARATOR()
                current += self.coordinate()
                current += self.unlexer.SEPARATOR()
                current += self.name()
                current += self.unlexer.SEPARATOR()
                current += self.score()
                current += self.unlexer.SEPARATOR()
                current += self.strand()
                current += self.create_node(UnlexerRule(src='\n'))

        return current
    line.min_depth = 3

    @depthcontrol
    def chrom(self):
        current = self.create_node(UnparserRule(name='chrom'))
        current += self.chromName()
        return current
    chrom.min_depth = 2

    @depthcontrol
    def coordinate(self):
        current = self.create_node(UnparserRule(name='coordinate'))
        
        from random import randint, random
        start, end = randint(0, 1e6), randint(0, 1e6)
        chance = random()
        while chance < 0.999 and start > end:
            start, end = randint(0, 1e6), randint(0, 1e6)
        current += self.create_node(UnlexerRule(src=str(start)))
        current += self.unlexer.SEPARATOR()
        
        current += self.create_node(UnlexerRule(src=str(end)))
        self.start = start
        self.end = end
        return current
    coordinate.min_depth = 1

    @depthcontrol
    def name(self):
        current = self.create_node(UnparserRule(name='name'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.unlexer.CHAR()

        return current
    name.min_depth = 1

    @depthcontrol
    def score(self):
        current = self.create_node(UnparserRule(name='score'))
        choice = self.choice([0 if [1, 1, 1, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_19', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_19', choice)] = self.unlexer.weights.get(('alt_19', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.NUM()
        elif choice == 1:
            current += self.unlexer.NUM()
            current += self.unlexer.NUM()
        elif choice == 2:
            current += self.unlexer.NUM()
            current += self.unlexer.NUM()
            current += self.unlexer.NUM()
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='1000'))
        return current
    score.min_depth = 0

    @depthcontrol
    def strand(self):
        current = self.create_node(UnparserRule(name='strand'))
        choice = self.choice([0 if [0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_25', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_25', choice)] = self.unlexer.weights.get(('alt_25', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='+'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='-'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='.'))
        return current
    strand.min_depth = 0

    @depthcontrol
    def thickStart(self):
        current = self.create_node(UnparserRule(name='thickStart'))
        
        from random import randint, random
        chance = random()
        if chance < 0.999:
            start = randint(self.start, self.end)
        else:
            start = randint(0, 1e6)
        self.tStart = start
        current += self.create_node(UnlexerRule(src=str(start)))
        return current
    thickStart.min_depth = 0

    @depthcontrol
    def thickEnd(self):
        current = self.create_node(UnparserRule(name='thickEnd'))
        from random import randint, random
        chance = random()
        if chance < 0.999:
            end = randint(self.tStart, self.end)
        else:
            end = randint(0, 1e6)
        self.tEnd = end
        current += self.create_node(UnlexerRule(src=str(end)))
        return current
    thickEnd.min_depth = 0

    @depthcontrol
    def itemRgb(self):
        current = self.create_node(UnparserRule(name='itemRgb'))
        choice = self.choice([0 if [0, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_34', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_34', choice)] = self.unlexer.weights.get(('alt_34', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='0'))
        elif choice == 1:
            current += self.unlexer.NUM255()
            current += self.create_node(UnlexerRule(src=','))
            current += self.unlexer.NUM255()
            current += self.create_node(UnlexerRule(src=','))
            current += self.unlexer.NUM255()
        return current
    itemRgb.min_depth = 0

    @depthcontrol
    def blockCount(self):
        current = self.create_node(UnparserRule(name='blockCount'))
        current += self.create_node(UnlexerRule(src='1'))
        current += self.create_node(UnlexerRule(src='4'))
        
        self.bCount = int(current)
        return current
    blockCount.min_depth = 0

    @depthcontrol
    def blockSizes(self):
        current = self.create_node(UnparserRule(name='blockSizes'))
        
        if self.unlexer.max_depth >= 2:
            for _ in range(self.bCount - 1):
                current += self.unlexer.NUMBER()
                current += self.create_node(UnlexerRule(src=','))
        current += self.unlexer.NUMBER()
        
        if self.bCount <= 1:
            self.lastBlock = int(str(current))
        else:
            self.lastBlock = int(str(current)[str(current).rfind(',') + 1:])
        return current
    blockSizes.min_depth = 2

    @depthcontrol
    def blockStarts(self):
        current = self.create_node(UnparserRule(name='blockStarts'))
        
        if self.unlexer.max_depth >= 2:
            for _ in range(self.bCount - 1):
                current += self.unlexer.NUMBER()
                current += self.create_node(UnlexerRule(src=','))
        from random import random
        if random() < 0.999:
            current += self.create_node(UnlexerRule(src=str(self.end - self.lastBlock)))
        else:
            current += self.unlexer.NUM()
        return current
    blockStarts.min_depth = 0

    @depthcontrol
    def chromName(self):
        current = self.create_node(UnparserRule(name='chromName'))
        current += self.create_node(UnlexerRule(src='chr'))
        choice = self.choice([0 if [1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_47', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_47', choice)] = self.unlexer.weights.get(('alt_47', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.NUM()
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='1'))
            current += self.unlexer.NUM()
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='2'))
            current += self.unlexer.NUM3()
        return current
    chromName.min_depth = 1

    default_rule = line

